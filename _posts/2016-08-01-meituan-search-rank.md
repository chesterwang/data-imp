---
layout: post
title: 美团O2O排序解决方案
categories: [general, programming ]
tags: [machine learning, search rank, search ]
fullview: false
comments: true
---

美团解决方案

# 工程架构
POI和deal的区别,POI是商家,deal是商品

特征监控: 离线数据处理中包括特征监控，特征的错误异常变动会直接影响排序的效果。特征监控主要监控覆盖率和取值分布，帮助相关人员及时发现数据质量问题。

为什么要分离线训练和在线训练两部分。我的观点是,可以这样认为，离线训练是全量的训练，在线训练是实时的增量训练。

架构前后可以分为,召回服务(即搜索服务),排序服务(rank service)。召回服务返回候选POI/deal集合，rank service根据A/B测试配置为用户分配排序策略/模型，应用策略/模型对候选集合进行排序。

### rank service内部流程

- L1粗粒度排序,较少的特征,可快速完成
- L2细粒度排序,需要加载较多特征,完成较慢。
- L3业务规则干预,人工干预。人工干预的数据如何设计使得不进入训练过程，以及这种对训练数据的污染程度和对模型的影响程度如何?
- 这里rank service会将排序展示结果记录到日志手机系统(也就是服务器端进行记录)，供在线/离线处理。这样是否合适?因为rank service并不是在排序展示逻辑中的最后一环。

- A/B测试
    - 白名单（White List）机制能保证配置用户使用给定的策略，以辅助相关的测试。

- 模型比较评估
    - interleaving方法来比较两种排序算法，对排序算法更为灵敏。
- 特征加载FeatureLoader
    - 特征之间有依赖关系，需要根据依赖关系来设计特征的并行获取和计算
    - 用akka实现

# 特征和模型

### 特征
启发

- 用户维度,品类偏好
- query维度,query长度/quey历史点击率/query历史转化率/query类型(主播类/专辑名/兴趣类)
- Deal/POI维度,
- 上下文维度(context)

### 模型
- Learning to Rank应用中，我们主要采用了Pointwise方法。采用用户的点击、下单和支付等行为来进行正样本的标注。从统计上看，点击、下单和支付等行为分别对应了该样本对用户需求的不同的匹配程度，因此对应的样本会被当做正样本，且赋予不断增大的权重。 

### 冷启动
一方面，在模型中引入了文本相关性、品类相似度、距离和品类属性等特征，确保在没有足够展示和反馈的前提下能较为准确地预测；另一方面，我们引入了Explore&Exploit机制，对新商家和团单给予适度的曝光机会，以收集反馈数据并改善预测。

### position bias
examination model

### 数据清洗

- 序列化

    - 按需配置

        数据清洗模块根据配置文件从数据源中抽取需要的字段,进行序列化(Serialization)之后存储在HDFS上.

    - 删除

        序列化的过程中，如果日志字段不合法或者单一用户曝光、点击或下单超出设定的阈值，相关日志都会被清洗掉，避免数据对模型训练造成影响。

    - 数据标注

        Map阶段：Map的输入为曝光、点击和下单三种HDFS数据。 用三个Mapper分别处理三种日志。数据分发的key为globalid。其中，如果点击和下单数据中的globalid字段为空（""），则丢弃该条日志（因为globalid为空无法和曝光日志join，会出现误标注）。
        reduce阶段: 将一次搜索的展示结果打散，然后和点击/下单/支付按照(搜索行为id,产品id)进行reduce,

    - skipabove

### 特征矩阵

- 特征合并模块，将所有来源合并为一个大文件，通过feature conf配置的特征和特征顺序，将特征序列化，然后写入Hive表。
- 特征监控模块每天监控特征的分布等是否异常。 特征矩阵的特征每日更新。
- 添加新的特征来源，只需要按照约定的格式生成数据源，配置路径，可自动添加。
- 添加新特征，在feature conf文件末尾添加相应的特征名，特征名字和数据源中的特征name保持一致，最后修改相应的特征Hive表结构。

### 特征在线使用
- 在线方面的使用主要是方便特征的获取，将线上需要的特征纳入特征矩阵统一管理，通过配置文件读取特征矩阵的特征，封装成Proto Buffers写入Medis（美团自主构建的Redis集群，支持分布式和容错），通过Medis key批量读取该key对应的特征，减少读取Medis的次数，从而缩减特征获取的时间，提高系统的性能。


- 序列化模块通过特征配置文件从特征矩阵抽取需要的特征，调用protoBuffer Lib将特征封装成protoBuffer的格式，写入Medis。
-         线上通过featureLoader服务从Medis读取数据，然后通过protoBufferLib反序列化数据，取到相应的特征值。

- 特征调研在使用hive作为存储的情况下是如何做到的?
- 特征融合，是用来融合在线使用的特征和调研的特征的。


### 监控系统

### 模型调研


###资料


### 喜马拉雅思考
1. 为什么支持 hbase es redis
2. 
